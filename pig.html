<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Pig Game</title>
<link rel='stylesheet' type='text/css' href='../Portfolio Site/styles.css' />
<script type='text/javascript' src='dice.js'></script>
<script type='text/javascript'>

var goal = 100  // the goal of Pig is always to score 100 points.

/* ### TAKING TURNS ### */

function contains(obj, seq) {
	var i = seq.length;
	while (i--) {
		if (seq[i] == obj) return true;
	}
	return false;
}

function roll(turn_total, outcome) {
	/* Performs the roll action, which adds outcome to turn_total, or loses the
    turn on outcome == 1.

    Arguments:
    turn -- number of points accumulated by the player so far during the turn
    outcome -- the outcome of the roll (the number generated by the die)

    Returns three values in order:
    - the number of points the player scores after the roll
      Note: If the turn is not over after this roll, this return value is 0.
            No points are scored until the end of the turn.
    - the player turn point total after the roll
    - a boolean; whether or not the player's turn is over
    
    >>> roll(7, 3)
    (0, 10, False)
    >>> roll(99, 1)
    (1, 0, True)
	*/
	if (outcome == 1) {
		return new Array(1, 0, true);
	}
	else {
		return new Array(0, turn_total+outcome, false);
	}
}

function hold(turn_total, outcome) {
	/* Performs the hold action, which adds turn_total to the player's score.

    Arguments:
    turn -- number of points accumulated by the player so far during the turn
    outcome -- the outcome of the roll, ie. the number generated by the die

    Returns three values in order:
    - the number of points the player scores after holding
    - the player turn total after the roll (always 0)
    - a boolean; whether or not the player's turn is over
    
    >>> hold(99, 1)
    (99, 0, True)
    */
	return new Array(turn_total, 0, true);
}

function take_turn(plan, dice, who, comments) {
	/* Simulate a single turn and return the points scored for the whole turn.

    Important: The d function should be called once, **and only once**, for
               every action taken!  Testing depends upon this fact.
    
    Arguments:
    plan -- a function that takes the turn total and returns an action function
    dice -- a function that takes no args and returns an integer outcome.
            Note: dice is non-pure!  Call it exactly once per action.
    who -- name of the current player
    comments -- a boolean; whether commentary is enabled
	*/
	var default_args = {
		'dice': make_fair_die(),
		'who': 'Someone',
		'comments': false
	};
	for (var i in arguments) {
		if (arguments[i] == 'undefined') arguments[i] = default_args[i];
	}
	var score_for_turn = 0;  // Point score in the whole turn
	var state =  new Array(0, 0, false);  // (points scored, turn_total, if turn is over)
	while (!state[2]) {
		var outcome = dice();
		var p = plan(state[1]);  // Avoids calling interactive_strategy twice
		state = p(state[1], outcome);
		if (comments) {
			commentate(p, outcome,  state[0], state[1], state[2], who);
		}
	}
	return state[0];  // returns the score for the turn
}

function take_turn_test() {
	/* Test the take_turn function using deterministic test dice.

    Sets of three consecutive numbers from the sequence tests are taken to
    construct dice from make_test_die. We then compare the return values of
    take_turn with the actual values listed in the sequence in results.
	*/
	var plan = make_roll_until_plan(10);  // plan is a function (see problem 2)
	var tests   = new Array( 4,6,1, 5, 3, 2,5,4,1, 2, 2,3,4,1, 5,6,1,3,1, 4, 5, 6, 3,5,2,1);
	var results = new Array(10,1,1,10,10,11,1,1,1,11,11,1,1,1,11,1,1,1,1,15,11,14,10,1);
	for (var i = 0; i < results.length; i++) {
		if (take_turn(plan, make_test_die(tests[i], tests[i+1], tests[i+2])) != results[i]) {
			throw 'take_turn not functioning properly';
		}
	}
	document.writeln('take_turn functioning properly');
}

/* ### COMMENTATING ### */

function commentate(action, outcome, score_for_turn, turn_total, over, who) {
	/* Print descriptive comments about a game event.
    
    action -- the action function chosen by the current player
    outcome -- the outcome of the die roll
    score_for_turn -- the points scored in this turn by the current player
    turn_total -- the current turn total
    over -- a boolean that indicates whether the turn is over
    who -- the name of the current player
	*/
	if (action == roll) document.writeln(draw_number(outcome));
	document.writeln(who, describe_action(action));
	if (over) document.writeln(who + ' scored ' + score_for_turn + ' point(s) for the turn.');
	else if (who != 'You') document.writeln(who + ' now has a turn total of ' + turn_total + ' point(s).');
}

function describe_action(action) {
	/* Generate a string that describes an action.

    action -- a function, which should be either hold or roll    

    If action is neither the hold nor roll function, the description should
    announce that cheating has occurred.

    >>> describe_action(roll)
    'chose to roll.'
    >>> describe_action(hold)
    'decided to hold.'
    >>> describe_action(commentate)
    'took an illegal action!'
	*/
	try {
		if (action == roll) return 'chose to roll.';
		else if (action == hold) return 'decided to hold.';
		else return 'took an illegal action.';
	}
	catch(err) {return 'took an illegal action.'};
}

function draw_number(n, dot) {
	/* Return an ascii art representation of rolling the number n.

    >>> print(draw_number(5))
     -------
    | *   * |
    |   *   |
    | *   * |
     -------
	 */
	 dot = dot || '*';
	 return draw_die(contains(n, Array(1,3,5)), contains(n, Array(4,5,6)), contains(n, Array(2,3,4,5,6)), (n==6), dot);
}

function draw_die(c, f, b, s, dot) {
	/* Return an ascii art representation of a die.

    c, f, b, & s are boolean arguments. This function returns a multi-line
    string of the following form, where the letters in the diagram are either
    filled if the corresponding argument is true, or empty if it is false.
    
     -------
    | b   f |
    | s c s |
    | f   b |
     -------    

    Note: The sides with 2 and 3 dots have 2 possible depictions due to
          rotation. Either representation is acceptable. 

    Note: This function uses Python syntax not yet covered in the course.
    
    c, f, b, s -- booleans; whether to place dots in corresponding positions
    dot        -- A length-one string to use for a dot
	*/
	border = ' -------'
	function draw(b) {return b ? dot: ' ';}
	drawed = [c, f, b, s].map(draw);
	c = drawed[0];
	f = drawed[1];
	b = drawed[2];
	s = drawed[3];
	var top = ['|', b, ' ', f, '|'].join(' ');
	var mid = ['|', s,  c , s, '|'].join(' ');
	var bot = ['|', f, ' ', b, '|'].join(' ');
	return [border, top, mid, bot, border].join('\n');
}

/* ### GAME SIMULATOR ### */

function play(strategy, opponent_strategy) {
	/* Simulate a game and return 0 if the first player wins and 1 otherwise.
    
    strategy -- The strategy function for the first player (who plays first)
    opponent_strategy -- The strategy function for the second player
	*/
	var score = 0;
	var opponent_score = 0;
	function sides() {
		/* Decides whether to use a 4- or 6- sided die. */
		if ((score + opponent_score) % 7) return 6;
		else return 4;
	}
	while (true) {
		score += take_turn(strategy(score, opponent_score), make_fair_die(sides()), 'You');
		if (score >= goal) return 0;
		opponent_score += take_turn(opponent_strategy(opponent_score, score), make_fair_die(sides()), 'The computer');
		if (opponent_score >= goal) return 1;
	}
}

/* ### BASIC STRATEGIES ### */

function make_roll_until_plan(turn_goal) {
	/* Return a plan to roll until turn total is at least turn_goal. */
	turn_goal = turn_goal || 20;
	function plan(turn) {
		if (turn >= turn_goal) return hold;
		else return roll;
	}
	return plan;
}

function make_roll_until_strategy(turn_goal) {
	/* Return a strategy to always adopt a plan to roll until turn_goal.
    
    A strategy is a function that takes two game scores as arguments and
    returns a plan (which is a function from turn totals to actions).
	*/
	function roll_until_strategy(score, opponent_score) {
		return make_roll_until_plan(turn_goal);
	}
	return roll_until_strategy;
}

function make_roll_until_strategy_test() {
	/* Test that make_roll_until_strategy gives a strategy that returns correct
    roll-until plans. */
	var strategy = make_roll_until_strategy(15);
	var plan = strategy(0, 0);
	if (plan(14) != roll) throw 'Should have returned roll';
	if (plan(15) != hold) throw 'Should have returned hold';
	if (plan(16) != hold) throw 'Should have returned hold';
}

/* ### EXPERIMENTS (PHASE 2) ### */

function average_value(fn, num_samples) {
	/* Compute the average value returned by fn over num_samples trials.
    
    >>> d = make_test_die(1, 3, 5, 7)
    >>> average_value(d, 100)
    4.0
	*/
	var total = 0;
	var i = num_samples;
	while (i--) {
		total += fn();
	}
	return total/num_samples;
}

function averaged(fn, num_samples) {
	/* Return a function that returns the average_value of fn when called.

    Note: To implement this function, you will have to use *args syntax, a new
          Python feature introduced in this project.  See the project
          description for details.

    >>> die = make_test_die(3, 1, 5, 7)
    >>> avg_die = averaged(die)
    >>> avg_die()
    4.0
    >>> avg_turn = averaged(take_turn)
    >>> avg_turn(make_roll_until_plan(4), die, 'The player', False)
    3.0

    In this last example, two different turn scenarios are averaged.  
    - In the first, the player rolls a 3 then a 1, receiving a score of 1.
    - In the other, the player rolls a 5 (then holds on the 7), scoring 5.
    Thus, the average value is 3.0

    Note: If this last test is called with comments=True in take_turn, the
    doctests will fail because of the extra output.
	*/
	num_samples = num_samples || 1000
	function avg_value() {
		var total = 0;
		var i = num_samples;
		while (i--) {
			total += fn.apply(this, arguments);
		}
		return total/num_samples;
	}
	return avg_value;
}

function compare_strategies(strategy, baseline) {
	/* Return the average win rate (out of 1) of strategy against baseline. */
	baseline = baseline || make_roll_until_strategy(20);
	var as_first = 1 - averaged(play)(strategy, baseline);
	var as_second = averaged(play)(baseline, strategy);
	return (as_first + as_second) / 2;
}

function eval_strategy_range(make_strategy, lower_bound, upper_bound) {
	/* Return the best integer argument value for make_strategy to use against
    the roll-until-20 baseline, between lower_bound and upper_bound (inclusive).

    make_strategy -- A one-argument function that returns a strategy.
    lower_bound -- lower bound of the evaluation range
    upper_bound -- upper bound of the evaluation range
	*/
	var best_value = 0;
	var best_win_rate = 0;
	var value = lower_bound;
	while (value <= upper_bound) {
		var strategy = make_strategy(value);
		var win_rate = compare_strategies(strategy);
		document.writeln(value + " win rate against baseline: " + win_rate);
		if (win_rate > best_win_rate) {
			best_win_rate = win_rate;
			best_value = value;
		}
		value++;
	}
	return best_value;
}

function run_strategy_experiments() {
	/* Run a series of strategy experiments and report results. */
	document.writeln(eval_strategy_range(make_roll_until_strategy,7,17));
	// document.writeln(eval_strategy_range(make_die_specific_strategy,0,20));
	// document.writeln(eval_strategy_range(make_pride_strategy,0,10));
	// document.writeln(eval_strategy_range(make_final_strategy,10,25));
}

function make_die_specific_strategy(four_side_goal, six_side_goal) {
	/* Return a strategy that returns a die-specific roll-until plan.
    
    four_side_goal -- the roll-until goal whenever the turn uses a 4-sided die
    six_side_goal -- the roll-until goal whenever the turn uses a 6-sided die
	*/
	six_side_goal = six_side_goal || 20;
	function die_specific_strategy(score, opponent_score) {
		if ((score + opponent_score) % 7) var goal = six_side_goal;
		else var goal = four_side_goal;
		return make_roll_until_plan(goal);
	}
	return die_specific_strategy;
}

function make_pride_strategy(margin, turn_goal) {
	/* Return a strategy that wants to finish a turn winning by at least margin.

    margin -- the size of the lead that the player requires
    turn_goal -- the minimum roll-until turn goal, even when winning
	*/
	turn_goal = turn_goal || 20;
	function pride_strategy(score, opponent_score) {
		function pride_plan(turn_total) {
			if (score + turn_total - opponent_score >= margin) {
				return make_roll_until_plan(turn_goal)(turn_total);
			}
			else return make_roll_until_plan(100)(turn_total);
		}
		return pride_plan;
	}
	return pride_strategy;
}

function final_strategy(score, opponent_score) {
	/* Returns different plans based on different situations. Optimize to win
    at least 60% of the time against the baseline make_roll_until_strategy(20).

    This final_strategy is based on a few key ideas:
        --It is disadvantageous to roll for higher pionts with four-sided die,
          as the chance of hitting a one increases. Therefore, the four-sided
          goal should be lower than the six-sided goal.
        --Following the same logic, it is advantageous to give the opponent a
          four-sided die. Thus, if the opportunity arises to give the opponent
          a four-sided die, this strategy should hold unless the strategy's
          current goal is exceptionally low. Thus, when it is possible to give
          the opponent a four-sided die, the goal for one's own strategy should
          be decreased.
        --If one is behind in score, it is better to take more risks in an
          attempt to catch up. Similarly, if the opponent is very close to
          winning (ie. within 20-ish of the goal, in which case he rolls until
          he wins), then the strategy conducts a last-ditch attempt to catchup,
          rolling until 100.
        --Finally, all of the goals and parameters used were optimized through
          extensive testing through both the eval_strategy_range function and
          the optimize function. This explains the choice of values chosen.

    Against the baseline strategy, this strategy performs at a comfortable
    66.5% win rate.
	*/
	function final_plan(turn_total) {
		// determines whether self is using four-sided dice
		if ((score + opponent_score) % 7) var selffour = false;
		else var selffour = true;
		// determines whether an opportunity to give opponent four-sided dice arises
		if ((score + opponent_score + turn_total) % 7) var oppfour = false;
		else var oppfour = true;
		// if such an opportunity arises
		if (oppfour) {
			if (selffour) var goal = 3;  // four side goal
			else var goal = 9;  // six side goal
		}
		// if no such opportunity arises
		else {
			if (selffour) var goal = 13;  // four side goal
			else var goal = 23;  // six side goal
		}
		// if win opportunity arises, hold
		if (turn_total + score > 100) return hold;
		// otherwise, play based on goals
		else {
			// adjust risk based on position, if not oppfour
			if (!oppfour) {
				if (opponent_score - score != 0) {
					goal += 13*(opponent_score - score)/50;
				}
			}
			if (opponent_score >= 92) {
				return roll;
			}
			else if (turn_total >= goal) {
				return hold;
			}
			else {
				return roll;
			}
		}
	}
	return final_plan;
}

function interactive_strategy(score, opponent_score) {
	/* Prints total game scores and returns an interactive plan.
    
    Note: this function uses Python syntax not yet covered in the course.
	*/
	document.writeln('You have ' + score + ' and they have ' + opponent_score + ' total score.');
	function plan(turn) {
		if (turn > 0) {
			document.writeln('You now have a turn total of ' + turn + ' points.');
		}
		while (true) {
			var response = prompt('(R)oll or (H)old?','R');
			if (response.toLowerCase()[0] == 'r') return roll;
			else if (response.toLowerCase()[0] == 'h') return hold;
			else document.writeln('Huh?');
		}
	}
	return plan;
}

play(interactive_strategy, final_strategy)			

</script>
</head>

<body>
</body>
</html>
